//: Playground - noun: a place where people can play

import UIKit

var wideth: Int8 // Int8型のwidethという名前の変数の宣言
wideth = 10
let height = 300 //指定しない場合、自動的にInt型になる。
print(wideth)

var age :UInt //UInt＝符号なし整数
//age = -1 //符号なし整数にマイナス値を代入するとエラー

//min,maxsw最大値、最小値を取得可能
print(Int.min,Int.max) //64ビットのMac OSXなので、Int64と同じ

var h = 0xff  //16進数は前に0xを付ける
var o = 0o10  //8進数は前に0oを付ける
var b = 0b100 //2進数は前に0bを付ける

let leadingZero = 000123 //前ゼロ
let population = 128_057_352 // 読みやすいように_（下線）で区切って記述できる

/*
 *
 *浮動小数点数
 *
 */
let pi = 3.14159 //デフォルトはDouble(64ビット)
let num = 170 + 2.345 //型を指定せずに、整数と浮動小数点数の計算式を初期値として与えた場合、変数の型はDoubleになる。

var angle: Float = 45.2
var radion = Double(angle) * pi //型変換
//違う型への変換は暗黙的には行われません。上の例のように、型が違う数値同士の計算をする場合は、型を明示的に変換して統一して計算する必要があります。Swiftは型に厳密な言語で、例えば、IntとUIntの場合でも型変換が必要です。

var d1 = 123.456	// 123.456
var d2 = 1.23456e2	// 1.23456に10の２乗を乗算した値。Eは指数表記の記号。Eの後の数字は指数値。
let leadingZero2 = 000123.456    // 前ゼロ
let bignumber = 123_456_789.012 // 読みやすいように_（下線）で区切って記述

//16進数指数表記
let val1 = 0xFp3    // F（15）に2の3乗を乗算した値。
let val2 = 0xCp-2   // C（12）に2の-2乗を乗算した値。
let val3 = 0xC.5p2  // .5=5/16(１６進数だから小数点以下のやつは÷１６)*p2=2の2乗
let val4 = 0xC.3p0  // .3+3/16*p0=2の0乗

/*
 *
 *数値の演算
 *
 */
1 + 2		// 足し算
12.3 - 4	// 引き算
45 / 5.0	// 割り算
2 * 3.5		// かけ算
11 % 3		//整数の余剰計算
-11 % 3		//マイナス値の余剰計算
-11.0.truncatingRemainder(dividingBy: 3.5)//11 % 3.5	//浮動小数点数の余剰計算
-11.5.truncatingRemainder(dividingBy: -5.0)//浮動小数点数同士の余剰計算

var a = 10
a += 3		// a=a+3
a -= 2		// a=a-2
//++a			// a=a+1　//できない
//var b = a++	// b=a=1　//できない
//
var f = 12.3
//++f			// 13.3　//できない
f += 5.2	// 18.5

/*
 *
 *  オーバーフロー演算子
 *
 */
var max = Int8.max // 最大値の代入
//max += 1 // オーバーフロー（ 演算においてビット幅を越えて桁が溢れること）となりエラーが発生する
max &+ 1 // 最小値になる

var max2 = UInt8.max // 最大値の代入
//max2 += 1 // オーバーフロー（最大値より大きい）となりエラーが発生する
max2 &+ 1 // 最小値になる

var min = UInt8.min // 最小値の代入
//max -= 1 // アンダーフロー（精度を保てなくなる下位桁が溢れること）となりエラーが発生する
min &- 1 // 最大値になる
min &- 10 //  ローテートする。0(最小値)-10=255-1-10

/*
 *
 *  ビット演算
 *
 */
var bits: UInt8 = 0b00001111 //二進数
var invertedBits = ~bits // ~ビットの反転　// 0b11110000

bits = 0b00001111 & 0b00111100  // AND演算
bits = 0b00001111 | 0b00111100  // OR演算
bits = 0b00001111 ^ 0b00111100  // XOR演算

//論理シフト
bits = 0b00001111
bits = 0b00001111 << 2 //左シフト
bits = bits >> 2 //右シフト

//算術シフト（符号ビットそのまま）
let bits2 = -30
bits2 << 2
bits2 >> 2
